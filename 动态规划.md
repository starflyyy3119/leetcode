# 背包问题
## 01背包
[分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)
```Java
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        int sum = 0;
        int[] w = new int[nums.length + 1], v = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            w[i + 1] = nums[i];
            v[i + 1] = nums[i];
        }
        if (sum % 2 != 0) return false;
        return zeroOneBag(v, w, n, sum / 2) == sum / 2;
    }
    private int zeroOneBag(int[] v, int[] w, int n, int m) {
        int[] f = new int[m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
            }
        }
        return f[m];
    }
}
```

- 物品的**体积**和**价值**都对应 nums 中的元素值。
- 背包的容积对应 **sum/2**。
- f[i][j] 表示使用前 i 个元素, 体积 <= j 的最大价值，因为体积和价值都是 nums 中的元素值，所以**最大价值顶多为 j**。

[1049. 最后一块石头的重量II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

```Java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        int[] v = new int[stones.length + 1], w = new int[stones.length + 1];
        for (int i = 0; i < stones.length; i++) {
            sum += stones[i];
            v[i + 1] = stones[i];
            w[i + 1] = stones[i];
        }
        int t = zeroOneBag(v, w, stones.length, sum / 2);
        return sum - 2 * t;
    }
    private int zeroOneBag(int[] v, int[] w, int n, int m) {
        int[] f = new int[m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
            }
        }
        return f[m];
    }
}
```
- 尽量让石头**分成重量相同的两堆**，这样相撞后剩下的石头最小。
- 如此将文件转化成了**分割等和子集**的问题。

[494. 目标和](https://leetcode-cn.com/problems/target-sum/)
```Java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        int[] v = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            v[i + 1] = nums[i];
        }
        if ((sum + target) % 2 == 1) return 0;
        if (Math.abs(target) > sum) return 0;
        return zeroOneBag(v, nums.length, (sum + target) / 2);
    }
    private int zeroOneBag(int[] v, int n, int m) {
        int[] f = new int[m + 1];
        f[0] = 1; // 装满容量为 0 的背包且使用前 0 个元素的方法有 1 个，f[1 ~ m] = 0
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {
                f[j] = f[j] + f[j - v[i]];
            }
        }
        return f[m];
    }
}
```

- 分成两部分, 一部分符号为 + 的(该部分的和为 x)，一部分为 - 的(该部分和为 sum - x)。得到 x - (sum - x) = target， 化简得到 x = (sum + target) / 2， 注意这时候 sum + target 必须为偶数，且 abs(target) < sum。
- 该题的 f[i][j] 表示使用**前 i 个数，装满容量为 j 的背包的方法有几种**。所以 f[0][0] = 1，也就是使用 0 个数，装满容量为 0 的背包的方法有 1 中。

[474. 1和0](https://leetcode-cn.com/problems/ones-and-zeroes/submissions/)

```Java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] f = new int[m + 1][n + 1];
        for (int i = 1; i <= strs.length; i++) {
            int zeros = numOfZero(strs[i - 1]);
            int ones = strs[i - 1].length() - zeros;
            for (int j = m; j >= zeros; j--) {
                for (int k = n; k >= ones; k--) {
                    f[j][k] = Math.max(f[j][k], f[j - zeros][k - ones] + 1);
                }
            }
        } 
        return f[m][n];
    }
    private int numOfZero(String str) {
        int cnt = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '0') cnt++;
        }
        return cnt;
    }
}
```
- 本题目背包容量是两个限制，所以增加一个维度即可。

## 完全背包
[518. 零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)

```Java
class Solution {
    public int change(int amount, int[] coins) {
        int[] v = new int[coins.length + 1];
        for (int i = 0; i < coins.length; i++) {
            v[i + 1] = coins[i];
        }
        return wholeBag(v, coins.length, amount);
    }
    // f[i][j] 表示使用前 i 种硬币，且总价值恰好为 j 的选法数目， v 从 1 开始
    // f[i][j] = f[i - 1][j] + f[i - 1][j - v] + .. f[i - 1][j - kv] 
    //         = f[i - 1][j] + f[i][j - v]
    private int wholeBag(int[] v, int n, int m) {
        int[] f = new int[m + 1];
        f[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = v[i]; j <= m; j++) {
                f[j] = f[j] + f[j - v[i]];
            }
        }
        return f[m];
    }
}
```

[377. 组合总和IV](https://leetcode-cn.com/problems/combination-sum-iv/)

```Java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] v = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) v[i + 1] = nums[i];
        return wholeBag(v, nums.length, target);
    }
    private int wholeBag(int[] v, int n, int m) {
        int[] f = new int[m + 1];
        f[0] = 1;
        for (int j = 0; j <= m; j++) {
            for (int i = 1; i <= n; i++) {
                if (j >= v[i]) f[j] += f[j - v[i]];
            }
        }
        return f[m];
    }
}
```
- 该题目与零钱兑换很相似，唯一差别在于该题求的是**排列数**。
- 如果求**组合数**就是外层for循环遍历物品，内层for遍历背包。
- 如果求**排列数**就是外层for遍历背包，内层for循环遍历物品。

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```Java
class Solution {
    public int climbStairs(int n) {
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int j = 0; j <= n; j++) {
            for (int i = 1; i <= 2; i++) {
                if (j - i >= 0) f[j] += f[j - i];
            }
        }
        return f[n];
    }
}
```
- 爬楼梯的完全背包写法。

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
```Java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] v = new int[coins.length + 1];
        for (int i = 0; i < coins.length; i++) {
            v[i + 1] = coins[i];
        }
        return wholeBag(v, coins.length, amount);
    }
    private int wholeBag(int[] v, int n, int m) {
        int[] f = new int[m + 1];
        Arrays.fill(f, 0x3f3f3f3f);
        f[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = v[i]; j <= m; j++) {
                f[j] = Math.min(f[j], f[j - v[i]] + 1);
            }
        }
        return f[m] == 0x3f3f3f3f ? -1 : f[m];
    }
}
```
- 本题的属性是最小值，在初始化的时候要注意将 f[1~m] 初始化成 0x3f3f3f3f，f[0] = 0.

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)
```Java
class Solution {
    public int numSquares(int n) {
        int i = 1;
        while (i * i <= n) i++;
        return wholeBag(i - 1, n);
    }
    private int wholeBag(int n, int m) {
        int[] f = new int[m + 1];
        Arrays.fill(f, 0x3f3f3f3f);
        f[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = i * i; j <= m; j++) {
                f[j] = Math.min(f[j], f[j - i * i] + 1);
            }
        }
        return f[m];
    }
}
```
- 与上题完全相同。

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)
```Java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // f[j] 表示 [0, j) 能否被字典中的前 i 个单词表示 
        boolean[] f = new boolean[s.length() + 1];
        f[0] = true;
        for (int j = 0; j <= s.length(); j++) {
            for (int i = 1; i <= wordDict.size(); i++) {
                String v = wordDict.get(i - 1); // 获取第 i 个单词
                int vLength = v.length(); // 获取第 i 个单词的长度
                if (j >= vLength) {
                    f[j] = f[j] || (f[j - vLength] && v.equals(s.substring(j - vLength, j)));
                }
            }
        }
        return f[s.length()];
    }
}
```
- 事实上，因为 substring 的过程中有考虑顺序，所以应该把物体遍历放在内层循环。


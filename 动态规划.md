# 背包问题
## 01背包
[分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)
```Java
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        int sum = 0;
        int[] w = new int[nums.length + 1], v = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            w[i + 1] = nums[i];
            v[i + 1] = nums[i];
        }
        if (sum % 2 != 0) return false;
        return zeroOneBag(v, w, n, sum / 2) == sum / 2;
    }
    private int zeroOneBag(int[] v, int[] w, int n, int m) {
        int[] f = new int[m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
            }
        }
        return f[m];
    }
}
```

- 物品的**体积**和**价值**都对应 nums 中的元素值。
- 背包的容积对应 **sum/2**。
- f[i][j] 表示使用前 i 个元素, 体积 <= j 的最大价值，因为体积和价值都是 nums 中的元素值，所以**最大价值顶多为 j**。

[1049. 最后一块石头的重量II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

```Java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        int[] v = new int[stones.length + 1], w = new int[stones.length + 1];
        for (int i = 0; i < stones.length; i++) {
            sum += stones[i];
            v[i + 1] = stones[i];
            w[i + 1] = stones[i];
        }
        int t = zeroOneBag(v, w, stones.length, sum / 2);
        return sum - 2 * t;
    }
    private int zeroOneBag(int[] v, int[] w, int n, int m) {
        int[] f = new int[m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
            }
        }
        return f[m];
    }
}
```
- 尽量让石头**分成重量相同的两堆**，这样相撞后剩下的石头最小。
- 如此将文件转化成了**分割等和子集**的问题。


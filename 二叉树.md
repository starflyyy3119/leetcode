# 二叉树定义
```Java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

# 二叉树的遍历方式
[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> ans = new ArrayList<>();
        traverse(root, ans);
        return ans;
    }
    private void traverse(TreeNode root, List<Integer> ans) {
        if (root == null) return;
        ans.add(root.val);
        traverse(root.left, ans);
        traverse(root.right, ans);
    }
}

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> st = new ArrayDeque<>();
        st.push(root);

        while (!st.isEmpty()) {
            TreeNode node = st.pop();
            res.add(node.val);
            if (node.right != null) st.push(node.right);
            if (node.left != null) st.push(node.left);
        }
        return res;
    }
}
```
- stack 后进先出，为了保证 先做 left, 先将 right 放进 stack

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        traverse(root, res);
        return res;
    }
    private void traverse(TreeNode root, List<Integer> res) {
        if (root == null) return;
        traverse(root.left, res);
        traverse(root.right, res);
        res.add(root.val);
    }
}

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> st = new ArrayDeque<>();
        st.push(root);

        while (!st.isEmpty()) {
            TreeNode node = st.pop();
            res.add(node.val);
            // 这样写是根右左的顺序, 最后进行一次翻转就行了
            if (node.left != null) st.push(node.left);
            if (node.right != null) st.push(node.right);
        }

        int i = 0, j = res.size() - 1;
        while (i < j) {
            int tmp = res.get(i);
            res.set(i, res.get(j));
            res.set(j, tmp);
            i++;
            j--;
        }
        return res;
    }
}
```
- 类似前序遍历的代码，这样写是**根右左**的顺序, 最后进行一次翻转就行了

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        traverse(root, res);
        return res;
    }
    private void traverse(TreeNode root, List<Integer> res) {
        if (root == null) return;
        traverse(root.left, res);
        res.add(root.val);
        traverse(root.right, res);
    }
}

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();

        TreeNode cur = root;
        Deque<TreeNode> st = new ArrayDeque<>();
        while (cur != null || !st.isEmpty()) {
            if (cur != null) {
                st.push(cur); // 不停向左边
                cur = cur.left;
            } else {
                cur = st.pop();
                res.add(cur.val); // 中
                cur = cur.right; // 右
            }
        }
        return res;
    }
}
```
- 由于**处理顺序和访问顺序**的不一致，需要引入 cur 指针来记录当前的节点。

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return new ArrayList<>();
        Queue<TreeNode> q = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        q.offer(root);

        while(!q.isEmpty()) {
            int size = q.size(); // 这里使用固定的 size，q.size() 会不停变化
            List<Integer> layer = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                layer.add(node.val);
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            res.add(layer);
        }
        return res;
    }
}
```
- 这里使用**固定的 size**，因为 q.size() 会不停变化。

# 二叉树的修改和构造
[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)
```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return root;

        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```
- 使用前序，后序，层序遍历都可以，但是使用**中序的递归方式**不可。
- 理由：先 left，然后交换 left 和 right， 那么此时如果再 right 的话，等于是最原始的 left 做了两次。

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return build(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);
    }
    private TreeNode build(int[] inorder, int[] postorder, int start1, int end1, int start2, int end2) {
        if (start1 > end1) return null;
        int root_val = postorder[end2];
        int root_index = -1;
        for (int i = start1; i <= end1; i++) {
            if (inorder[i] == root_val) root_index = i;
        }
        TreeNode root = new TreeNode(root_val);
        int leftLength = root_index - start1;
        root.left = build(inorder, postorder, start1, root_index - 1, start2, start2 + leftLength - 1);
        root.right = build(inorder, postorder, root_index + 1, end1, start2 + leftLength, end2 - 1);
        return root;
    }
}
```
- 中序 + 后序， 中序 + 前序 可以唯一确定一颗二叉树。
- 前序 + 后序**不能唯一确定**一颗二叉树, 如。
    ![](./fig/tree.png)


[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)
```Java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums, 0, nums.length - 1);
    } 
    private TreeNode build(int[] nums, int start, int end) {
        if (start > end) return null;
        int max_index = -1;
        for (int i = start; i <= end ; i++) {
            if (max_index == -1 || nums[i] > nums[max_index]) max_index = i;
        }
        TreeNode root = new TreeNode(nums[max_index]);
        root.left = build(nums, start, max_index - 1);
        root.right = build(nums, max_index + 1, end);
        return root;
    }
}
```
- 与上题是同样的思路。

[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)
```Java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        TreeNode root = new TreeNode(root1.val + root2.val);
        root.left = mergeTrees(root1.left, root2.left);
        root.right = mergeTrees(root1.right, root2.right);
        return root;
    }
}
```

# 二叉树的属性

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)
```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isSym(root, root);
    }
    private boolean isSym(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return true;
        if (root1 == null || root2 == null) return false;
        return root1.val == root2.val && isSym(root1.left, root2.right) && isSym(root1.right, root2.left);
    }
}

class Solution {
    public boolean isSymmetric(TreeNode root) {
        Deque<TreeNode> st = new LinkedList<>(); // ArrayDeque 不能插入 null, LinkedList 可以
        st.push(root.left);
        st.push(root.right);
        while (!st.isEmpty()) {
            TreeNode root1 = st.pop();
            TreeNode root2 = st.pop();
            if (root1 == null && root2 == null) continue;
            if (root1 == null || root2 == null || root1.val != root2.val) return false;
            st.push(root1.left);
            st.push(root2.right);
            st.push(root1.right);
            st.push(root2.left);
        }
        return true;
    }
}
```

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
```Java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```
- 还可以使用层序遍历。

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
```Java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        // 注意题目中说的叶子节点要求，左右孩子都没有。
        if (root.left != null && root.right == null) return 1 + minDepth(root.left);
        if (root.right != null && root.left == null) return 1 + minDepth(root.right);
        return 1 + Math.min(minDepth(root.left), minDepth(root.right));
    }
}
```
- 注意**叶子节点**的定义，要**左右孩子都没有**。
![](./fig/leaf.png)





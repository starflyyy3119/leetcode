# 二叉树定义
```Java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```
# 二叉树的遍历方式
[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> ans = new ArrayList<>();
        traverse(root, ans);
        return ans;
    }
    private void traverse(TreeNode root, List<Integer> ans) {
        if (root == null) return;
        ans.add(root.val);
        traverse(root.left, ans);
        traverse(root.right, ans);
    }
}

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> st = new ArrayDeque<>();
        st.push(root);

        while (!st.isEmpty()) {
            TreeNode node = st.pop();
            res.add(node.val);
            if (node.right != null) st.push(node.right);
            if (node.left != null) st.push(node.left);
        }
        return res;
    }
}
```
- stack 后进先出，为了保证 先做 left, 先将 right 放进 stack

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        traverse(root, res);
        return res;
    }
    private void traverse(TreeNode root, List<Integer> res) {
        if (root == null) return;
        traverse(root.left, res);
        traverse(root.right, res);
        res.add(root.val);
    }
}

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> st = new ArrayDeque<>();
        st.push(root);

        while (!st.isEmpty()) {
            TreeNode node = st.pop();
            res.add(node.val);
            // 这样写是根右左的顺序, 最后进行一次翻转就行了
            if (node.left != null) st.push(node.left);
            if (node.right != null) st.push(node.right);
        }

        int i = 0, j = res.size() - 1;
        while (i < j) {
            int tmp = res.get(i);
            res.set(i, res.get(j));
            res.set(j, tmp);
            i++;
            j--;
        }
        return res;
    }
}
```
- 类似前序遍历的代码，这样写是**根右左**的顺序, 最后进行一次翻转就行了

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        traverse(root, res);
        return res;
    }
    private void traverse(TreeNode root, List<Integer> res) {
        if (root == null) return;
        traverse(root.left, res);
        res.add(root.val);
        traverse(root.right, res);
    }
}

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();

        TreeNode cur = root;
        Deque<TreeNode> st = new ArrayDeque<>();
        while (cur != null || !st.isEmpty()) {
            if (cur != null) {
                st.push(cur); // 不停向左边
                cur = cur.left;
            } else {
                cur = st.pop();
                res.add(cur.val); // 中
                cur = cur.right; // 右
            }
        }
        return res;
    }
}
```
- 由于**处理顺序和访问顺序**的不一致，需要引入 cur 指针来记录当前的节点。

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return new ArrayList<>();
        Queue<TreeNode> q = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        q.offer(root);

        while(!q.isEmpty()) {
            int size = q.size(); // 这里使用固定的 size，q.size() 会不停变化
            List<Integer> layer = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                layer.add(node.val);
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            res.add(layer);
        }
        return res;
    }
}
```
- 这里使用**固定的 size**，因为 q.size() 会不停变化。

# 二叉树的修改和构造
[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)
```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return root;

        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```
- 使用前序，后序，层序遍历都可以，但是使用**中序的递归方式**不可。
- 理由：先 left，然后交换 left 和 right， 那么此时如果再 right 的话，等于是最原始的 left 做了两次。

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return build(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);
    }
    private TreeNode build(int[] inorder, int[] postorder, int start1, int end1, int start2, int end2) {
        if (start1 > end1) return null;
        int root_val = postorder[end2];
        int root_index = -1;
        for (int i = start1; i <= end1; i++) {
            if (inorder[i] == root_val) root_index = i;
        }
        TreeNode root = new TreeNode(root_val);
        int leftLength = root_index - start1;
        root.left = build(inorder, postorder, start1, root_index - 1, start2, start2 + leftLength - 1);
        root.right = build(inorder, postorder, root_index + 1, end1, start2 + leftLength, end2 - 1);
        return root;
    }
}
```
- 中序 + 后序， 中序 + 前序 可以唯一确定一颗二叉树。
- 前序 + 后序**不能唯一确定**一颗二叉树, 如。
    ![](./fig/tree.png)





